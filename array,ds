Sathish would like to prepare a present for his wife: they have an anniversary! He decided to buy her exactly nn flowers.
Sathish went to a flower shop, and he was amazed to see that there are mm types of flowers being sold there, and there is unlimited supply of flowers of each type. Sathish wants to choose flowers to maximize the happiness of his wife. He knows that after receiving the first flower of the ii-th type happiness of his wife increases by aiai and after receiving each consecutive flower of this type her happiness increases by bibi. That is, if among the chosen flowers there are xi>0xi>0 flowers of type ii, his wife gets ai+(xi−1)⋅biai+(xi−1)⋅bi additional happiness (and if there are no flowers of type ii, she gets nothing for this particular type).
Please help Sathish to choose exactly nn flowers to maximize the total happiness of his wife.
Input
The first line contains the only integer tt (1≤t≤100001≤t≤10000), the number of test cases. It is followed by tt descriptions of the test cases.
Each test case description starts with two integers nn and mm (1≤n≤1091≤n≤109, 1≤m≤1000001≤m≤100000), the number of flowers Sathish needs to choose and the number of types of available flowers.
The following mm lines describe the types of flowers: each line contains integers aiai and bibi (0≤ai,bi≤1090≤ai,bi≤109) for ii-th available type of flowers.
The test cases are separated by a blank line. It is guaranteed that the sum of values mm among all test cases does not exceed 100000100000.
Output
For each test case output a single integer: the maximum total happiness of Sathish's wife after choosing exactly nn flowers optimally.

Sample input:
2
4 3
5 0
1 4
2 2

5 3
5 2
4 2
3 1
Sample output:
14
16

Code:
import sys
T= int(input())
 
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
for t in range(T):
 
    n,m = map(int,input().split())
    pref=[0]
    f = [[0,0]for x in range(m+1)]
    f=LLI(m)
    f.sort(reverse=True)
    for i in range(1,m+1): pref.append(f[i-1][0] + pref[i-1])
 
    ans=0
    mmax =0
    for i in range(0,m):
        l=0
        r=m
        use=0
 
        while l<r:
            if f[i][1] <= mmax:
                use=r
                break
            mid = (l+r)//2
            if f[mid][0] >= f[i][1]:
                use=mid+1
                l = mid + 1
 
            else:
                r = mid
        mmax =  f[i][1]
        if use>=n:
            ans=max(ans,pref[n])
 
        else:
            if use>=i+1:
                ans=max(ans, pref[use] + f[i][1]*(n-use))
            else:
                ans=max(ans , pref[use] + f[i][0] + f[i][1]*(n-use-1))
    print(ans)
    if t!= T-1:
        _ = input()


Input
1
1 7
334569692 287790954
828776938 450248098
812787473 543828736
353202854 229469066
105035292 19740770
294918734 142174357
944609166 419900619
Output
944609166
Input
1
7 7
875211518 78149272
372527826 28528254
777595365 608227558
861586350 722262664
996903444 323312570
299704754 233926739
778198166 197484491
Output
5734020171
Input
1
7 1
107402237 913999333
Output
5591398235
Input
1
7 7
10122721 121764855
397678435 423586551
203091798 455230154
500000000 409776311
421303531 418861532
455230153 307287064
417664664 419771248
Output
3053512092
