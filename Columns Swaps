You are given a table a of size 2×n (i.e. two rows and n columns) consisting of integers from 1 to n.

In one move, you can choose some column j (1≤j≤n) and swap values a1,j and a2,j in it. Each column can be chosen no more than once.

Your task is to find the minimum number of moves required to obtain permutations of size n in both first and second rows of the table or determine if it is impossible to do that.

You have to answer t independent test cases.

Recall that the permutation of size n is such an array of size n that contains each integer from 1 to n exactly once (the order of elements doesn't matter).

Input
The first line of the input contains one integer t (1≤t≤2⋅104) — the number of test cases. Then t test cases follow.

The first line of the test case contains one integer n (1≤n≤2⋅105) — the number of columns in the table. The second line of the test case contains n integers a1,1,a1,2,…,a1,n (1≤a1,i≤n), where a1,i is the i-th element of the first row of the table. The third line of the test case contains n integers a2,1,a2,2,…,a2,n (1≤a2,i≤n), where a2,i is the i-th element of the second row of the table.

It is guaranteed that the sum of n does not exceed 2⋅105 (∑n≤2⋅105).

Output
For each test case print the answer: -1 if it is impossible to obtain permutation of size n in both first and the second rows of the table, or one integer k in the first line, where k is the minimum number of moves required to obtain permutations in both rows, and k distinct integers pos1,pos2,…,posk in the second line (1≤posi≤n) in any order — indices of columns in which you need to swap values to obtain permutations in both rows. If there are several answers, you can print any.

Example
inputCopy
6
4
1 2 3 4
2 3 1 4
5
5 3 5 1 4
1 2 3 2 4
3
1 2 1
3 3 2
4
1 2 2 1
3 4 3 4
4
4 3 1 4
3 2 2 1
3
1 1 2
3 2 2
outputCopy
0

2
2 3 
1
1 
2
3 4 
2
3 4 
-1
Code:
import sys

def input():
	return sys.stdin.readline().strip()

def solve():
	n = int(input())
	a = list(map(int,input().split()))
	b = list(map(int,input().split()))
	pos = [[] for i in range(n+1)]
	for i in range(n):
		pos[a[i]].extend((i,0))
		pos[b[i]].extend((i,1))
		if len(pos[a[i]]) > 4 \
		or len(pos[b[i]]) > 4:
			print(-1)
			return
	was = [False]*(n+1)
	res = []
	for i in range(1, n):
		if not was[i]:
			x = i
			p = pos[i][0]
			if pos[i][1] == 1:
				one, two = [p], []
			else:
				one, two = [], [p]
			first = p
			while True:
				was[x] = True
				if pos[x][0] == p:
					p = pos[x][2]
					if p == first:
						break
					r = pos[x][3]
				else:
					p = pos[x][0]
					if p == first:
						break
					r = pos[x][1]
				if r == 0:
					one.append(p)
					x = b[p]
				else:
					two.append(p)
					x = a[p]
			if len(one) > len(two):
				one = two
			res.extend(one)
	'''for i in res:
		a[i], b[i] = b[i], a[i]
	if len(set(a)) != n:
		print(-1)
		return'''
	print(len(res))
	print(' '.join([str(i+1) for i in res]))

for i in range(int(input())):
	solve()
